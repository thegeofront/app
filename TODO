# Wednesday
- [X] get the setup over at this side 
- [X] figure out how to return a tuple from rust 
  -> this is hard. 
  -> option 1: make it all rust objects. They can be converted, and are fine to use when using 'inspectable'
  -> option 2: foreign objects.
  -> I Think [this][game-of-life] is our best chance forward. retrieving a pointer, and buffer size, creating the buffer on the javascript side

- [X] make a very dumb, basic type encoding
  - just based around string enums, and 'thrusting' that the any type contains what we need when it has 'typename'
  - TODO typechecking! 
  -> THIS IS HARD AND IMPORTANT 
  -> we cant do this naively, we will require some sort of extra ensurance that we are dealing with the right types. 
  -> Edit: came up with a 'trait' idea, where foreign types can 'earn' the right to be treated as if it were a `Point`, `Vector`, or `Mesh`, if it contains the right data.


- [X] make some sort of data import widget, or a random list of points generator 

[game-of-life]: https://rustwasm.github.io/book/game-of-life/implementing.html#rendering-to-canvas-directly-from-memory

RNG 

- [ ] return points as { buffer: Float64Array, typename: "multi-point-3"}
- [ ] return triangles as { buffer: Uint32Array, typename: "int-matrix-3"}
- [ ] return mesh as { typename: "Mesh", vertices: {... typename: MultiPoint}, triangles: {typename: IntMatrix-3}}
- [ ] visualize the shit out of it! 


# Thursday

- [X] text file input 
- [X] text file output
- [X] get a nice xyz file, visualize it using something else to know what it is 
- [X] xyz string to multiVector
- [X] visualize multiVector 
- [X] multiVector to xyz string
- [X] test that these are the same strings
- [X] multiVector to list<vector>
- [X] list<vector> to multiVector 
- [X] expand traits 
- [X] do better trait checking 
- [X] fix the trait bugs

> The way the traits are actually being used right now are waaaayyy dumber than the whole trait system now implemented
> This suggest that this might be over-engineered. Maybe we just need to do some minor, runtime type checking, if all 
> field are present, of the correct type, instead of some weird connection-time type checking 
> ohwell...

# friday

- [ ] move the list of vectors left
- [X] add lists to the visualizer
- [X] refactor graph a bit
- [x] expand full graph recalculation starters to inputless nodes
- [X] reintroduce cables 
- [X] implement the cables a bit , remove the workaround code
- [X] make widgets more 'normal' compared to operations: remove the excessive 'ifs'
- [X] fix bugs
- [ ] detect list at connect-time

- implement the 'list comparrison' thing
- [ ] generate random vectors
- [ ] apply the DT to these points 

- apply more runtime / connection-time list


- [X] callback & calculation overhaul
   - [ ] list calculation overhaul 
   - [ ] how to specify a list? 
   - [ ] how to take items from a list? 
   - [ ] Nodes do not like variation of their input & output sockets. This is also troublesome for graph's multilinkedlist reasons



  TODO
- [] internal (widget) operations
- internal gf-types: 

  - vector-2
  - polyline-2
  - polygon-2
  - multi-vector-2
  - multi-polyline-2
  - mutli-polygon-2
  
  - point-3
  - mesh-3
  - multi-point-3